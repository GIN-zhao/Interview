1. Output
printf("格式控制字符串"， 输出列表)；    如：printf("%s", string);
putchar（字符数据）；   如：char  a_c=‘h’；putchar（a_c）;
puts（字符串）；            如：puts（“hello girl”）;

2. #pragma 预处理命令
#pragma comment。将一个注释记录放置到对象文件或可执行文件中。
#pragma pack。用来改变编译器的字节对齐方式。
#pragma code_seg。它能够设置程序中的函数在obj文件中所在的代码段。如果未指定参数，函数将放置在默认代码段.text中。
#pragma once。保证所在文件只会被包含一次，它是基于磁盘文件的，而#ifndef则是基于宏的。

3. C++不允许仅根据函数的返回类型重载函数名称；可以编写两个名称相同，参数也相同的函数，其中一个是const，另一个不是。

4. 加加运算符并不会提高运行时效率，反而会降低，只是为了代码更精简。

5. 静态数据成员要在类内声明 ，类外定义和初始化。

6. c语言提供一种特殊的运算符，逗号运算符，优先级别最低，它将两个袭及其以上的式子联接起来，从左往右逐个计算表达式，整个表达式的百值为最后一个表达式的值。如：（3+5,6+8）称为逗号表达式，其求解过程先表达式1，后度表达式2，整个表达式值是表达式2的值，如：（3+5，6+8）的值是14，知a=(a=35,a4)的值是60，而（a=35,a4）的值是60，a的值是15.

7. strlen计算字符串的长度，以\0为字符串结束标记；sizeof来返回类型以及静态分配的对象、结构或数组所占的空间，返回值跟对象、结构、数组所存储的内容没有关系；具体而言，当参数分别如下时，sizeof返回的值表示的含义如下：数组——编译时分配的数组空间大小；指针——存储该指针所用的空间大小（存储该指针的地址的长度，是长整型，应该为4）；类型——该类型所占的空间大小；对象——对象的实际占用空间大小；函数——函数的返回类型所占的空间大小。函数的返回类型不能是void.

8. 会打印出多少个"-"? fork()函数是通过系统调用实现进程的拷贝。第一次for循环，执行完fork函数之后，系统中有两个一模一样的进程，并且都执行到printf函数处，这一次循环会打印出两个“ - ”符号第二次进入for循环，经过fork函数，第一次循环中产生的两个进程分别再次分裂，这时会有4个进程打印 “-”符号，所以最终结果是6个。

``` cpp
for (int i = 0; i < 2; i++)
{
    fork();
    printf("-\n");
}
```

9. strlen(char*)函数求的是字符串的实际长度，它求得方法是从开始到遇到第一个'\0',如果你只定义没有给它赋初值，这个结果是不定的，它会从aa首地址一直找下去，直到遇到'\0'停止。 而sizeof()返回的是变量声明后所占的内存数，不是实际长度，此外sizeof不是函数，仅仅是一个操作符，strlen是函数。

10. 局部变量存在栈区
new出的变量存在堆区。
static变量和全局变量由操作系统释放。

11. 首先要理解的是递归是借助栈来实现的，自动变量是存储在栈里面的，随着递归的进行，自动创建和销毁。
外部变量和静态变量存放在静态存储区。外部变量和静态变量是不能作为递归函数的参数的。首先，如果可以，那还要这个参数干什么呢？直接函数内改变不就行了？其次，递归的过程中，会创建变量存放在栈顶，如果是静态变量，递归结束后是不会被销毁的，如果忘记了，那就会造成空间很大的浪费。编译器会禁止这么用的。最后，自动变量可以大体上等价于局部变量。但也不完全相同，是C++11的新特性，很好很强大。 

12. Performance difference of C++ malloc and C malloc.

13. Application Programming Interface 应用程序接口（API）

14. 通过Dijkstra计算图G中的最短路径时，需要指定起点s(即从顶点s开始计算)。此外，引进两个集合S和U。S的作用是记录已求出最短路径的顶点(以及相应的最短路径长度)，而U则是记录还未求出最短路径的顶点(以及该顶点到起点s的距离)。
操作步骤：
- 初始时，S只包含起点s；U包含除s外的其他顶点，且U中顶点的距离为”起点s到该顶点的距离”例如，U中顶点v的距离为(s,v)的长度，然后s和v不相邻，则v的距离为∞。
- 从U中选出”距离最短的顶点k”，并将顶点k加入到S中；同时，从U中移除顶点k。
- 更新U中各个顶点到起点s的距离。之所以更新U中顶点的距离，是由于上一步中确定了k是求出最短路径的顶点，从而可以利用k来更新其它顶点的距离；例如，(s,v)的距离可能大于(s,k)+(k,v)的距离。
- 重复步骤2和3，直到遍历完所有顶点。

15. [A-Star](https://blog.csdn.net/NichChen/article/details/84945431), 又称 A*，它结合了 Dijkstra算法的节点信息（倾向于距离起点较近的节点）和贪心算法的最好优先搜索算法信息（倾向于距离目标较近的节点）。可以像 Dijkstra 算法一样保证找到最短路径，同时也像贪心最好优先搜索算法一样使用启发值对算法进行引导。